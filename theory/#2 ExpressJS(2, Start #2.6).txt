저장하면 재시작하고나서 그런 다음 BABEL이 코드의 변화를 감지하고 서버를 재시작한다.

그렇기 때문에 --delay2를 추가한다. 저장할 때마다 2초를 기다렸다가 서버를 시작하는데

이렇게 하면 babel이 변환을 완료할 때까지 기다려줄 수 있는 것이다.

-------------------------------------------------

< middleware >

express에서 middleware란 처리가 끝날 때까지 연결되어있는 것이다.

웹사이트에 접속하려할 때가 시작이다. 시작되면 index파일을 실행하고

우리의 app이 route가 존재하는지 살펴본다("/")이 부분이고 그럼 home을 요청하는구나라고 알아야한다.

home을 찾은다음에 handleHome이라는 함수를 호출하고 handleHome은 응답을 전송해 send안의 내용을 응답한다.


app.get("/", handleHome);

const handleHome = (req, res) => res.send("hi i'm home ! change !");

보통 연결은 간단히 되지않는다. 어떠한 중간과정을 거쳐야한다 유저와 마지막 응답사이.

그사이 존재하는게 있고 그것은 middleware이다.

express에서의 모든 함수는 middleware가 될 수 있다.

예를들어 하나 만들어본다.  const betweenHome = () => console.log("I'm between");

app.get("/", betweenHome, handleHome); 
->유저가 ("/")홈을 요청하고 handleHome에 send응답하는 사이에 betweenHome을 둬본다.

새로고침해보면 console에 I'm between이 찍힌다. 왜냐면 이것이 middleware가 되었기 때문이다.

이것이 beginning과 start사이에 있으니깐. 유저의 home(/)요청과 handleHome사이에 있는것이다.

여기서 문제는 나는 권한을 주지 않았다. 크롬으로부터 온 요청을 계속 처리할 지에 대해
-> 그 요청이 handleHome으로 처리될지를. 그 요청을 계속 처리할수있는 권한을 줘야하는거지.

그래서 req, res다음 next라는 key를 이용한다 여기서 인자들의 명은 아무거나해도됨 편의상 req요청 res응답 next다음 의미

express의 모든 route와 그런 것들은 connection을 다루는 건 req, res, next를 갖고있다.

///////////////////////  code  /////////////////////////////////

const handleHome = (req, res) => res.send("hi i'm home ! change !");

const handleProfile = (req, res) => res.send("this is profile");

const betweenHome = (req, res, next) => {
  console.log("I'm between");
  next();
};
///////////////////////  code  /////////////////////////////////

코드에서 handleHome과 handleProfile도 req, res, next를 가질 수 있지만, 여기서 넣지않는 이유는

저 둘은 마지막 함수이기 때문이다. 이경우에 between 함수가 middleware이다.

그다음 next()함수를 호출한다 앞에서 말했듯이 인자명은 상관없다 req, res, abc로 인자를줬으면

호출도 abc();로 줘야한다. 알기쉽게 next로했다.

이렇게 호출하면 다음 middleware가 호출되는데 이것이 handleHome이 될것이다.
->app.get("/", betweenHome, handleHome);

정상적으로 handleHome의 send응답이 화면에 뜰것이고, console에 Between이라고 찍힌다.

express서버가 양파라고 생각하자, 여러개의 층이 있는것이고, 그것이 middleware이다.

계속 까다가 양파의 중심인 마지막 함수가 뭔가를 반환하는것이다 유저에게 

너도 알다싶히, 반환할게 없다면 계속 Loading중 표시가 된다. 
-> app.get에 betweenHome만 사이에추가하고 betweenHome함수를 제대로 작성하지않았을경우

너는 니가 원하는만큼 middleware함수를 가질수있고, 그것은 너를 편하게 해줄것이다.

middleware로 유저의 로그인 여부를 체크하거나, 파일을 전송할 때 중간에서 가로챌 수 있고 

로그를 작성하는 middleware도있고 여러가지 방면으로 쓰일 수 있다. 

지금 사용하는 between은(middleware) 오직 이루트[app.get("/", betweenHome, handleHome);] 에대해서만 사용되고있다.

반면 /profile쪽을 보면 console에 아무것도 찍히지않고 send만 화면에 출력된다. 왜냐면 middleware가 없기때문.

이제 미들웨어를 app.use(between)으로 경로들의 제일 위에 둔다.

app.use(betweenHome);

app.get("/", handleHome);

app.get("/profile", handleProfile);

기본적으로 웹싸이트에서 일어나는 모든 것에 대해 위와같은 middleware를 사용한다.

app.use를 어디다 두느냐가 중요하다. 

접속이있으면, 위에서부터 아래로 실행이 된다. 위와같이 middleware를 먼저써야 

그런 다음에 route가 반환된다. 원하는 만큼의 middleware를 써도된다. 그런다음에 route를 처리한다.

app.get("/", handleHome);

app.use(betweenHome);

app.get("/profile", handleProfile);

이런식으로 순서를 두면. 만약 ("/") home으로 갈시 실행이 되지않는다.

이것이 middleware의 기본이다. app.get내부에 둘수도있고 전역으로도 둘 수 있다.

예를들어 IP를체크하는 middleware가 있다고 가정할때 거부할 IP주소를 찾았다고하면 접속을 취소할수도있다.

============================================================================

* 서버 재시작 딜레이 시간 주기
 - node --exec babel-node index.js --delay 2

* express
 - middleware
   - 처리가 끝날 때까지 연결되어 있는
   - 유저의 요청과 서버의 응답 사이에 있는 것
   - express에서의 모든 함수는 middleware가 될 수 있음
     get 함수의 인자를 3개 주고 2번째에 middleware 함수를 넣으면 됨
     마지막 함수는 res.send 해야 웹사이트가 로딩중이지 않음
   - 모든 요청에 미들웨어 설정 방법 : app.use(); // get함수(route 처리) 이전에 먼저 설정

===========end #2.6 Express Core: Middlewares part One ================