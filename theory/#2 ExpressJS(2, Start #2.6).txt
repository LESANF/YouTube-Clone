저장하면 재시작하고나서 그런 다음 BABEL이 코드의 변화를 감지하고 서버를 재시작한다.

그렇기 때문에 --delay2를 추가한다. 저장할 때마다 2초를 기다렸다가 서버를 시작하는데

이렇게 하면 babel이 변환을 완료할 때까지 기다려줄 수 있는 것이다.

-------------------------------------------------

< middleware >

express에서 middleware란 처리가 끝날 때까지 연결되어있는 것이다.

웹사이트에 접속하려할 때가 시작이다. 시작되면 index파일을 실행하고

우리의 app이 route가 존재하는지 살펴본다("/")이 부분이고 그럼 home을 요청하는구나라고 알아야한다.

home을 찾은다음에 handleHome이라는 함수를 호출하고 handleHome은 응답을 전송해 send안의 내용을 응답한다.


app.get("/", handleHome);

const handleHome = (req, res) => res.send("hi i'm home ! change !");

보통 연결은 간단히 되지않는다. 어떠한 중간과정을 거쳐야한다 유저와 마지막 응답사이.

그사이 존재하는게 있고 그것은 middleware이다.

express에서의 모든 함수는 middleware가 될 수 있다.

예를들어 하나 만들어본다.  const betweenHome = () => console.log("I'm between");

app.get("/", betweenHome, handleHome); 
->유저가 ("/")홈을 요청하고 handleHome에 send응답하는 사이에 betweenHome을 둬본다.

새로고침해보면 console에 I'm between이 찍힌다. 왜냐면 이것이 middleware가 되었기 때문이다.

이것이 beginning과 start사이에 있으니깐. 유저의 home(/)요청과 handleHome사이에 있는것이다.

여기서 문제는 나는 권한을 주지 않았다. 크롬으로부터 온 요청을 계속 처리할 지에 대해
-> 그 요청이 handleHome으로 처리될지를. 그 요청을 계속 처리할수있는 권한을 줘야하는거지.

그래서 req, res다음 next라는 key를 이용한다 여기서 인자들의 명은 아무거나해도됨 편의상 req요청 res응답 next다음 의미

express의 모든 route와 그런 것들은 connection을 다루는 건 req, res, next를 갖고있다.

///////////////////////  code  /////////////////////////////////

const handleHome = (req, res) => res.send("hi i'm home ! change !");

const handleProfile = (req, res) => res.send("this is profile");

const betweenHome = (req, res, next) => {
  console.log("I'm between");
  next();
};
///////////////////////  code  /////////////////////////////////

코드에서 handleHome과 handleProfile도 req, res, next를 가질 수 있지만, 여기서 넣지않는 이유는

저 둘은 마지막 함수이기 때문이다. 이경우에 between 함수가 middleware이다.

그다음 next()함수를 호출한다 앞에서 말했듯이 인자명은 상관없다 req, res, abc로 인자를줬으면

호출도 abc();로 줘야한다. 알기쉽게 next로했다.

이렇게 호출하면 다음 middleware가 호출되는데 이것이 handleHome이 될것이다.
->app.get("/", betweenHome, handleHome);

정상적으로 handleHome의 send응답이 화면에 뜰것이고, console에 Between이라고 찍힌다.

express서버가 양파라고 생각하자, 여러개의 층이 있는것이고, 그것이 middleware이다.

계속 까다가 양파의 중심인 마지막 함수가 뭔가를 반환하는것이다 유저에게 

너도 알다싶히, 반환할게 없다면 계속 Loading중 표시가 된다. 
-> app.get에 betweenHome만 사이에추가하고 betweenHome함수를 제대로 작성하지않았을경우

너는 니가 원하는만큼 middleware함수를 가질수있고, 그것은 너를 편하게 해줄것이다.

middleware로 유저의 로그인 여부를 체크하거나, 파일을 전송할 때 중간에서 가로챌 수 있고 

로그를 작성하는 middleware도있고 여러가지 방면으로 쓰일 수 있다. 

지금 사용하는 between은(middleware) 오직 이루트[app.get("/", betweenHome, handleHome);] 에대해서만 사용되고있다.

반면 /profile쪽을 보면 console에 아무것도 찍히지않고 send만 화면에 출력된다. 왜냐면 middleware가 없기때문.

이제 미들웨어를 app.use(between)으로 경로들의 제일 위에 둔다.

app.use(betweenHome);

app.get("/", handleHome);

app.get("/profile", handleProfile);

기본적으로 웹싸이트에서 일어나는 모든 것에 대해 위와같은 middleware를 사용한다.

app.use를 어디다 두느냐가 중요하다. 

접속이있으면, 위에서부터 아래로 실행이 된다. 위와같이 middleware를 먼저써야 

그런 다음에 route가 반환된다. 원하는 만큼의 middleware를 써도된다. 그런다음에 route를 처리한다.

app.get("/", handleHome);

app.use(betweenHome);

app.get("/profile", handleProfile);

이런식으로 순서를 두면. 만약 ("/") home으로 갈시 실행이 되지않는다.

이것이 middleware의 기본이다. app.get내부에 둘수도있고 전역으로도 둘 수 있다.

예를들어 IP를체크하는 middleware가 있다고 가정할때 거부할 IP주소를 찾았다고하면 접속을 취소할수도있다.

============================================================================

* 서버 재시작 딜레이 시간 주기
 - node --exec babel-node index.js --delay 2

* express
 - middleware
   - 처리가 끝날 때까지 연결되어 있는
   - 유저의 요청과 서버의 응답 사이에 있는 것
   - express에서의 모든 함수는 middleware가 될 수 있음
     get 함수의 인자를 3개 주고 2번째에 middleware 함수를 넣으면 됨
     마지막 함수는 res.send 해야 웹사이트가 로딩중이지 않음
   - 모든 요청에 미들웨어 설정 방법 : app.use(); // get함수(route 처리) 이전에 먼저 설정

===========end #2.6 Express Core: Middlewares part One ================

Morgan이라는 Middleware를 설치해보자, logging에 도움을주는것이다, logging은 무슨 일이 어디서 일어났는지 기록하는 것이다.

설치: npm install morgan, 설치 후 import해줘야한다. import morgan from "morgan";  import다음 morgan 대신 닉네임(아무거나) 사용가능

기존 between middleware 삭제 app.use(morgan("인자로여러가지"));

우리가 사용할건 morgan말고 helmet도 있다. 헬멧은 node.js 앱의 보안에 도움이 되는 것이다.

마찬가지로 import helmet from "helmet"; 하고 app.use(helmet()); 하면 된다. 이것은 보안을 위한것이고 좋은 버릇이다.

그리고 가끔은 middleware가 연결을 끊을 수 있다. 

const middleWare = (req, fuckresponse, next) => {
  fuckresponse.send("im middleware");
};  

따로 middleware를 만들고 app.get("/", middleWare, handleHome); 이 route에 추가해주면.

middleware는 연결을 끊어줄수가있다 만약 res.send를 실행하는 함수를 발동하면. next함수 대신에 !

< cookie parser, body parser >

둘다 express의 middleware이다. cookie와 body를 다르는 걸 도와준다.

기본적으로 누군가 form을 채운다면, form을 채워서 너에게 전송한다면, 이 form은 서버에 의해서 받아져야만 한다.

만약 내가 이름과 비밀번호를 입력했다면, 전송하면, 서버에 의해 받아져야만 한다. 특정한 형태로.

form을 받았을때. 그 데이터를 갖고 있는 req(request object)에 접근할 수 있길 원한다. 그걸 위해 내가 해야할것이 일단 

body-parser의 설치이다. npm install body-parser 

body로부터 정보를 얻을 수 있게 해주는것이다.

그리고 cookie-parse을 설치한다. npm install cookie-parser

cookie에 유저 정보를 저장할것이다. session을 다루기 위해서. 그래서 둘 다 필요한것이다.

cookie parser와 body parser를 import해주자 import ~~ from ~~

import하고 app.use로 middleware 사용한다.

body-parser에는 우리가 정의해야할 옵션이 있다. 그 중 json이란 옵션이 있고, text, urlencoded등 모든 것들에 대해 이해해야한다.

왜냐면 우리 서버가 우리가 무엇을 전송하는지 알 수 있어야 하니까. 예를 들어 json을 전송한다면, 서버가 json을 이해하길 바래야겠지.

우리가 일반적인 html form을 전송한다면, 서버가 urlencoded라는 걸 이애하길 바래야된다. 이런 방법이 기본적이고 이게 우리 서버를 설정하는 내용이고

이게 서버가 유저로부터 받은 데이터를 이해하는 방법이다, 유저로부터 받은 cookie를 이해하는 방법이다.

이와같은 것을한번해본다.
-> app.use(bodyParser.unlencoded({extended : true});  그리고 우리 서버가 이해하길 바라는데 form에서 받은 데이터 뿐만아니라

json도 이해하길 바라기 때문에  app.use(bodyParser.json()); 추가.  기억해라 코드는 위에서부터 아래로 작동함. top to bottom

====================요약====================

* Morgan(middleware) : logging(무슨 일이 어디서 일어났는지 기록)
 - npm install morgan
 - import morgan from "morgan";
 - app.use(morgan());
 - 인자로 로깅 옵션 설정 가능
   - "tiny", "combined", "common", "dev"

* helmet(middleware) : node.js 앱 보안에 도움
 - npm install helmet
 - import helmet from "helmet"
 - app.use(helmet());

* middleware로 연결(connection) 끊기
 - 미들웨어가 res.send 호출하면 거기서 연결 끝

* cookie parser(middleware) : session을 다루기 위해 cookie에 사용자 정보 저장
 - npm install cookie-parser
 - import cookieParser from "cookie-parser";
 - app.user(cookiePaerser());

* body parser(middleware) : form 데이터 가진 request object에 접근
 - npm install body-parser
 - import bodyParser from "body-parser";
 - app.use(bodyParser());
 - 옵션
   - json : bodyParser.json();
   - html : bodyParser.urlencoded({extended:true});

===========================end #2.7 ==================================

