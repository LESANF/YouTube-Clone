세션을 설치하자 npm install express-session

app에 express-session을 import, 이니셜전에 app.use(session({}));

session안에는 필수적으로 들어가는 옵션이있음. = secret, 옵션들은 여러가지가 있다 쿠키나 도메인을 원하는 대로 바꾸거나 유효한 기간설정에 대해

그중에서도 필수적으로 해야하는게 secret이다. secret은 무작위 문자열로서 쿠키에 들어있는 session ID를 암호화하기 위한 것임.

예를 들어 session ID를 전송할 때, 실제로 그 ID값 그대로 보내는 것은 아님. 실제로는 암호화된 상태로 보낸다. 누군가 정보를 알게 되는걸 원치않으니까.

이 secret에는 어떤 문자열이든 넣어줘도 동작함. https://randomkeygen.com/ ( 이싸이트에서 가져와서쓰자 )
-> 나는 mWWga9RygQpDHcV4U5rdrDA3xTTMGgqT를  사용할거임.

그리고 이 문자열을 바로 secret : 에 넣어주는게 아니라 env에 넣어서 환경변수로 쓸거임. 왜냐면 누군가 이 문자열을 보지않아야 하기때문. 보면 쿠키를 해독할 수 있게 됨.

.env로 이동해서 COOKIE_SECRET이라는 변수 생성.

app.use(
  session({
    secret: process.env.COOKIE_SECRET,
    resave: true,
    saveUninitialized: false
  })
);

이렇게 session을 사용하여 필수적인 옵션인 secret을 추가하였다. secret말고 강의에서 문구가떠서 추가해준 옵션이있는데 나는 안뜬다. 그래도 강의를 따라 넣어보자

resave는 세션을 강제로 저장하게 되는거. true로 값줌, saveUninitialized는 초기화되지않은 세션을 저장소에 저장한다. 새로운 세션이지만 변경되지 않은 세션은 초기화되지 않는다.

로그인 세션에 이용하려면 false를써라. false로 값줌.

서버를키고 로그인해보면 COOKISE에 connect.sid로 쿠키가 만들어져있는걸 확인할 수 있다. value는 암호화 되어있는것이고 이건 userid임.

내가 웹브라우저를 새로고침 할 때마다, 즉 이 정보를 웹서버로 전송할 때마다 서버에서는 passport 인증과정을 호출하고 

passport는 deserialize를 통해 내가 어느 사용자인지 식별할 수 있게 된다.

header.pug에서 임시로 썻던 isAuthenticated는 이제 없으니까 if !user 조건만 남겨둔다.

로그인을하면 header가 업로드, 프로필, 로그아웃으로 바뀔것이고. req.user를 확인해보면 누가 무슨 요청을 하는지 알 수 있다. 

이제 req.user는 이 어플리케이션 어디든 존재하는거임. 이게 가능한 이유는 쿠키때문.

connect.sid (우리가 inspect로 보고있는 쿠키)는 express로 보내지고 있다. express는 session을 이용함으로써, 쿠키를 가지게 되는거다.

그리고 passport.session을 통하여 session을 이요하는데, 즉 session이 가진 쿠키를 이용한다는거다.

그리고 그 passport로 desirializeUser가 사용자를 확인하는거임.

app.use(session({~~~})은 쿠키를 해독함. 해독되어서 ID가 1이다 라는 예처럼 알 수 있는거고. 그 ID는 passport.session()으로 넘어가게 됨.

passport로 넘어가면 deseriailizeUser함수가 실행되고, 사용자를 식별하게 되면, passpor는 그 사용자를 middleware나 routes의 request(요청) object에 할당됨.

그래서 어느 route에서든 로그인한 사용자가 누구인지 체크할 수 있다. 

middlewares.js에 res.locals.user를 req.user || null로 바꾸자  {} 빈객체나 null이나 같음. 유저가 존재하지 않으면 null이 되겠지.

서버를 재시작해보면 로그인이 풀려있음. <- 이건 문제임. req.user를 콘솔로 찍어보면 undefined되어있음 좋지않은 결과.

다시 로그인해보자. 로그인도 되었고 header도 바꼇고 req.user로 로그인한 유저도 보임.

그러나 서버를 다시 재시작하면 session이 사라짐 다시 로그인이 풀리고, 내가 서버를 매번 새로 실행시킬 때 마다 session 정보를 잃게됨.

왜내면 session정보 (session({secret:~~blabla}), 쿠키 정보들을 우리의 메모리에 저장하고 있기 때문이다. 

이런부분은 바꿔야함. 우리는 session이 유지되기를 바란다. 내가 서버를 잃거나 바꾸는 일이 있다고 해도.

서버는 기억해야한다. 어느 사용자가 어느 쿠키를 가지고 있는지.

===================================#6.4 END=====================================

데이터베이스(MongoDB)를 사용해서 세션을 저장하자.

connect-mongo를 사용할거임. 다운로드하자 npm i connect-mongo

connect-mongo를 써서, session에게 데이터를 MongoStore라는 저장소에 저장할거임.

다운받았으니 app.js에 import하자. 이제 사용이 가능함.

const CokieStore = MongoStore(session); MongoStore는 session 오브젝트가 필요함으로 안에 session을 적음.

그 다음으로, session 설정으로 와서, store를 추가하자.

그전에 아래와같은 저장소를 mongo와 연결시켜야함. 이부분이 매우 중요한데, CokieStroe와 mongo간의 연결을 만들어줘야함. 

그전에 mongoose를 써야한다. mongoDB와의 연결을 해주는 일은 mongoose가하니까. 

아래와 같이 mongooseConnection은 mongoose.connection으로 연결 시킬 수 있다. (db.js를 연결시킬 수 있음)

app.use(
  session({
    secret: process.env.COOKIE_SECRET,
    resave: true,
    saveUninitialized: false,
    store: new CokieStore({
      mongooseConnection: mongoose.connection // new CokieStore를 연결시키기 위한 연결 방법.
    })
  })
);

이제 js파일을 수정하거나 서버가 재시작된다고 하더라도, 쿠키를 계속 보존할 수 있고, 여전히 로그인 상태를 유지할 수 있다.

서버를 재시동하면 로그인이 유지되어있다.

아직 해결할 문제들이 몇가지 더 있는데  routes들로 출입을 제한하는것. 

이미 로그인 된 사용자는 Join화면으로는 접근을 못하게 한다는 말. 직접 URL을 localhost:4000/Join으로 치면 지금은 접속이됨.

이런식으로 되면안됨. 이미 로그인 된 사람이니까, 가입 화면으로 가는 건 허용되면 안됨.

미들웨어를 하나 만들어서 설정하자. middlewares.js로 이동.

export const onlyPublic = (req, res, next) => {
  if (req.user) {
    res.redirect(routes.home);
  } else {
    next();
  }
};

다음과 같이 미들웨어를 하나 만듦. 유저가 로그인된상태라면 home으로 리다이렉트, 아니면 아무것도하지않고 next로 다음 경로로진입.

이렇게 만들어진 미들웨어를 우리가 적용한 controller(함수)에 넣어주자.

globalRouter로와서 만약 사용자가 로그인된 상태라면 JOIN과 LOGIN하면을 보게 하고 싶지 않게하자. 

JOIN, LOGIN화면은 LOGOUT된 사람들만 볼 수 있음. join / login 루트들에게 onlypublic 넣어줌.

잊지말자 우리는 passport와 session덕분에 req.user를 통해 로그인된 사용자가 누구인지 알 수 있는거임.

그리고 editProfile, changePassword 는 사용자 전용이어야함. 이것에 대한 middleware도 하나만들자.

export const onlyPrivate = (req, res, next) => {
  if (req.user) {
    next();
  } else {
    res.redirect(routes.home);
  }
};

로그인되어있는 상태어야지 프로필 수정과 패스워드 변경이 가능함. 아닐시 home으로 보냄.

userRouter로와서 editProfile과 changePassword에 미들웨어추가. 미들웨어를 쓰려면 import 시켜줘야함. vsc는 똑똑해서 자동적으로 해줌 

videoRouter로와서 업로드, 비디오수정, 비디오 삭제 역시 사용자 전용이기때문에, onlyPrivate추가.

이런 설정이 보안의 첫걸음임. 

===================================#6.5 END=====================================

github 인증관련 부분을 해보자. 일단 설치를 해야함. npm install passport-github

깃헙 개발자 페이지에서 application 등록을 해야함. 그리고 strategy도 작성해야함.

깃헙에서 application을 생성하자. https://github.com/settings/applications/new

홈페이지 URL = http://localhost:4000/ 그리고 인증 후에 callback하게될 URL을 적는창이 있는데, 어떻게 작동하는 원리냐면

일단, 우리는 사용자를 깃헙 페이지로 보냄 특별한 URL로 -> 사용자를 거기로 보내면, 깃헙이 이 사람들(application)에게 너의 정보를 줘도 괜찮으십니까? 라고 물어봄

-> 사용자가 괜찮다고 응답하면, 사용자의 승인을 받은것이다. - > 깃허브는 다시 우리 application으로 돌려보내는데, 그 사용자의 정보도 같이 줄 것이다.

페이스북으로 예를어보자. 페이스북으로 가입하기를 누르면, 그사용자를 페이스북으로 보내고, 페이스북은 사용자 정보를 줘도 되겠냐고 물어보고, 그걸 사용자가 허락하면

다시 우리 웹사이트로 돌아오면서 우리가 요청한 정보도 함께 오는 것이다.

passport.js로가서 우리가 설치한 GithubStrategy를 가져오자(import) (passport-github) 

그리고 사용을하면됨. passport.use(new GithubStrategy({})) 새로운 Strategy를 생성.

clientID를 적어줘야함. 깃헙에서 application을 생성할때 callbackURL을 적는칸에 적어주자 http://localhost:4000/auth/github/callback

위와같은 링크는 형식이 정해진게아님. 하지만 보통 이런식으로 사용함 auth/facebook/callback 이런식으로. 모든 form이 채워졌으니 Register application을 눌러주자.

이제 Client ID와 Client Secret을 얻었음. passport GithubStrategy의 설명에서도 볼 수 있듯이 클라이언트아이디, 클라이언트시크릿을 얻음. 

이런것들은 환경변수(.env)로 넣어주자.

GH_ID="86804e26a148e1f32749"
GH_SECRET="3c29830279cf851e8c2eef14d12f79c0b1892c13"

우리는 절대로 이와같은 키를 공유하면 안됨. 절대로.

new GithubStrategy({
    clientID: process.env.GH_ID,
    clientSecret: process.env.GH_SECRET,
    callbackURL: "http://localhost:4000/auth/github/callback"
  })

다음과같이 새롭게만든 Strategy에 넣어줌.

그리고 함수도 하나 넣어줘야하는데, 사용자가 깃헙에서 돌아왔을 때 실행이 되는 함수다. 사용자가 깃헙으로 갔다가 돌아오면서 사용자 정보를 들고온다면

해당함수가 실행되는거다. 관련함수는 userController에 적어줄거임.

githubLoginCallback로 함수선언. 그리고 인자들을 줘야하는데 (accessToken, refreshToken, profile, cb) 마지막 cb=callback function

마지막 콜백함수는 passport로부터 우리에게 제공되는 거다. 함수인데, 이게 실행되면, passport에게 사용자가 성공적으로 로그인되었다고.

우리는 함수내부 내용에 아무것도 작성하지않을거고 일단, console.log로 일단 인자들을 읽어보자.

그리고 로그아웃 관련 함수는 req.logout()을 하면 될거다 passport를 사용할 때. 

만들어진 githubLoginCallback 함수를 passport로가서 new GithubStrategy에 넣어주자. 에러가 뜰 수 도있는데 auto import가 이뤄지지 않은걸수도 있으니 확인해보자.

여기까지가 깃헙에서 돌아오는 과정이고 보내는 과정을 하지않음. 이건 갔다가 오는과정이고 가는 과정을 해줘야함.

userController에서 githubLogin함수를 하나더만들자. 

===================================#6.6 END=====================================




